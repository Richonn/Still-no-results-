# Questionnaire de révision IFT-3003 - Niveau Avancé

# Dans le modèle de Tuckman, les conflits surviennent principalement à quelle étape?
- [ ] Formation
- [x] Turbulence
- [ ] Normalisation
- [ ] Performance

---

# Les tests unitaires font partie de quelle discipline dans le Processus Unifié?
- [ ] Discipline des tests
- [x] Discipline d'implémentation
- [ ] Discipline d'analyse et conception
- [ ] Les deux : tests et implémentation

---

# Quel jalon marque la fin de la phase d'Élaboration?
- [ ] LCO (Lifecycle Objectives)
- [x] LCA (Lifecycle Architecture)
- [ ] IOC (Initial Operational Capability)
- [ ] PR (Product Release)

---

# Dans Git, qu'est-ce qu'un "référentiel"?
- [ ] Un document de référence du projet
- [ ] Une branche principale
- [x] La base de données versionnée contenant tous les éléments de configuration
- [ ] Le serveur central de Git

---

# Quelle affirmation est FAUSSE concernant les tests unitaires?
- [ ] Ils utilisent des mocks pour isoler l'unité
- [ ] Ils doivent être rapides à exécuter
- [x] Ils testent l'intégration entre plusieurs composants
- [ ] Ils suivent le principe F.I.R.S.T.

---

# En intégration continue, que devrait-on faire si 95% des tests passent?
- [ ] C'est acceptable, on peut continuer
- [ ] On devrait viser 98%
- [x] Le build est considéré comme cassé et doit être réparé immédiatement
- [ ] On peut faire un commit si nos propres tests passent

---

# Quelle est la bonne relation mathématique pour les tests selon la pyramide?
- [ ] Tests système > Tests intégration > Tests unitaires
- [ ] Tests intégration > Tests unitaires > Tests système
- [x] Tests unitaires > Tests intégration > Tests système
- [ ] Tous les types devraient être en quantité égale

---

# Un risque de projet affecte principalement:
- [ ] La qualité technique du produit
- [x] Le déroulement et l'échéancier du projet
- [ ] L'organisation dans son ensemble
- [ ] Le marché et la compétition

---

# Dans le cycle de vie en cascade, quand découvre-t-on généralement les problèmes majeurs?
- [ ] Pendant la phase de conception
- [ ] Pendant l'implémentation
- [x] Pendant les tests, donc tard dans le projet
- [ ] Pendant l'analyse des besoins

---

# Quelle affirmation est VRAIE concernant un processus cérémonieux?
- [ ] Il n'utilise jamais de documentation
- [x] Il a beaucoup de formalisme et de documentation détaillée
- [ ] Il est toujours mieux qu'un processus opportuniste
- [ ] Il ne convient qu'aux petites équipes

---

# En déploiement continu, "Done means released" signifie:
- [ ] Le code est écrit et commité
- [ ] Les tests unitaires passent
- [ ] Le code est déployé en staging
- [x] Le code est déployé en production et accessible aux utilisateurs

---

# Quelle stratégie de gestion de risque consiste à faire supporter le risque par quelqu'un d'autre?
- [ ] Éviter
- [x] Transférer
- [ ] Atténuer
- [ ] Plan B

---

# Dans le Processus Unifié, quelle phase a le plus d'activités de tests planifiés?
- [ ] Création
- [ ] Élaboration
- [x] Construction
- [ ] Toutes les phases également

---

# Qu'est-ce qu'une exigence de contrainte?
- [ ] Une exigence difficile à implémenter
- [ ] Une exigence non-fonctionnelle
- [x] Une limitation imposée (budget, technologie, règlement)
- [ ] Une exigence fonctionnelle prioritaire

---

# Le Design by Contract définit:
- [ ] Les contrats légaux entre développeurs
- [ ] Les interfaces entre modules
- [x] Les préconditions, postconditions et invariants
- [ ] Les accords de niveau de service

---

# Dans un test unitaire, que teste-t-on principalement?
- [ ] L'intégration avec la base de données
- [ ] Les interactions entre modules
- [x] Le comportement logique d'une seule unité
- [ ] La conformité aux besoins du client

---

# Quelle affirmation est FAUSSE sur l'intégration continue?
- [ ] Chaque membre devrait intégrer au moins une fois par jour
- [ ] Tous les tests doivent passer à 100%
- [x] Les commits peuvent être faits même si le code ne compile pas localement
- [ ] Le build cassé doit être réparé immédiatement

---

# Un facteur de risque est:
- [ ] Un risque très grave
- [ ] Un risque accepté par l'équipe
- [x] L'origine ou la cause d'un ou plusieurs risques
- [ ] Un risque qui s'est déjà réalisé

---

# Dans la planification à deux niveaux, le plan d'itération couvre:
- [ ] Toute la durée du projet (6-12 mois)
- [x] Une seule itération (2-4 semaines)
- [ ] Une phase complète du projet
- [ ] L'ensemble des itérations d'une phase

---

# Quelle affirmation est VRAIE sur les mocks?
- [ ] Ils remplacent les tests d'intégration
- [x] Ils permettent d'isoler l'unité testée de ses dépendances
- [ ] Ils ne doivent jamais être utilisés dans les tests unitaires
- [ ] Ils sont utilisés dans tous les types de tests

---

# La principale différence entre analyse et conception est:
- [ ] L'analyse est plus difficile
- [ ] La conception vient toujours avant l'analyse
- [x] L'analyse se concentre sur QUOI, la conception sur COMMENT
- [ ] Il n'y a pas vraiment de différence

---

# Un test d'acceptation vérifie principalement:
- [ ] Que le code compile sans erreur
- [ ] Que les composants s'intègrent bien
- [x] Que le système répond aux besoins du client
- [ ] La performance du système

---

# Dans Git (système distribué), chaque développeur possède:
- [ ] Seulement sa branche locale
- [ ] Les fichiers actuels sans historique
- [x] Une copie complète de l'historique du projet
- [ ] Seulement les commits de la dernière semaine

---

# Quelle affirmation est FAUSSE sur les bases de référence (baselines)?
- [ ] Elles marquent des configurations stables
- [ ] Elles permettent de revenir à un état connu
- [x] Elles doivent être créées après chaque commit
- [ ] Elles servent de points de repère

---

# Le cycle de vie transformationnel convient particulièrement pour:
- [ ] Les projets avec exigences bien définies
- [x] Les projets de recherche avec incertitude importante
- [ ] Les projets de maintenance
- [ ] Les projets critiques nécessitant haute fiabilité

---

# En TDD (Test-Driven Development), l'ordre correct est:
- [ ] Écrire le code, écrire les tests, refactorer
- [x] Écrire le test (rouge), écrire le code (vert), refactorer (bleu)
- [ ] Refactorer, écrire le test, écrire le code
- [ ] Concevoir, écrire les tests, implémenter

---

# Quel type de test utilise le format Given-When-Then?
- [ ] Tests unitaires
- [ ] Tests d'intégration
- [ ] Tests de système
- [x] Tests d'acceptation

---

# Dans le triangle de fer (3 dimensions d'un projet), si on réduit le temps:
- [ ] Seul le coût augmente
- [ ] Seule la qualité diminue
- [x] Le coût augmente et/ou la qualité diminue
- [ ] Rien ne change si l'équipe travaille plus fort

---

# Une itération est considérée réussie quand:
- [ ] Tout le code prévu est écrit
- [ ] L'équipe a travaillé toutes les heures planifiées
- [ ] 90% des objectifs sont atteints
- [x] Tous les risques, fonctionnalités et objectifs de qualité sont atteints

---

# Quelle affirmation est VRAIE sur le déploiement continu?
- [ ] Il faut déployer après chaque commit
- [ ] Il élimine le besoin d'environnement de staging
- [x] Les déploiements doivent être automatisés et fréquents
- [ ] Il ne convient qu'aux startups

---

# L'environnement de staging sert principalement à:
- [ ] Développer de nouvelles fonctionnalités
- [ ] Remplacer l'environnement de développement
- [x] Tester dans des conditions similaires à la production
- [ ] Archiver les anciennes versions

---

# Quelle affirmation est FAUSSE sur les risques?
- [ ] Un risque = incertitude × perte
- [ ] Les risques doivent être identifiés tôt
- [x] Un risque avec probabilité faible ne nécessite jamais d'action
- [ ] Les risques doivent être surveillés continuellement

---

# Dans le Processus Unifié, les disciplines d'ingénierie sont:
- [ ] Seulement implémentation et tests
- [ ] Gestion de projet et gestion de configuration
- [x] Requis, Analyse & Conception, Implémentation, Tests
- [ ] Création, Élaboration, Construction, Transition

---

# Un élément de configuration dans Git pourrait être:
- [ ] Seulement un fichier source .java
- [ ] Seulement une branche complète
- [x] Un fichier, un répertoire ou un module entier versionné
- [ ] Seulement le README du projet

---

# Quelle est la durée typique d'une itération dans le Processus Unifié?
- [ ] 1 jour
- [ ] 1 semaine
- [x] 2-4 semaines
- [ ] 2-3 mois

---

# Les tests unitaires testent les préconditions, postconditions et:
- [ ] Les interfaces utilisateur
- [ ] Les intégrations
- [x] Les invariants de classe
- [ ] Les exigences du client

---

# Quelle affirmation est VRAIE sur un besoin vs une exigence?
- [ ] Un besoin est toujours technique
- [x] Un besoin exprime un problème, une exigence une solution
- [ ] Une exigence est moins précise qu'un besoin
- [ ] Besoin et exigence sont des synonymes

---

# En intégration continue, avant de faire un push, on devrait:
- [ ] Attendre l'approbation du chef d'équipe
- [ ] Faire un push immédiatement sans tester
- [x] Intégrer et tester dans son espace privé d'abord
- [ ] Créer une nouvelle branche pour chaque changement

---

# Le principe KISS signifie qu'on devrait:
- [ ] Toujours utiliser les technologies les plus récentes
- [ ] Optimiser chaque ligne de code
- [x] Garder la conception simple et éviter la sur-conception
- [ ] Minimiser le nombre de classes

---

# Quelle affirmation est FAUSSE sur la pyramide des tests?
- [ ] Plus de tests unitaires que d'intégrés
- [x] Les tests de système sont les plus importants car ils testent tout
- [ ] Les tests unitaires sont à la base
- [ ] Les tests de système sont au sommet

---

# Un test d'intégration utilise:
- [ ] Toujours des mocks pour toutes les dépendances
- [x] Les vraies instances des composants testés
- [ ] Seulement des données de test simulées
- [ ] L'interface utilisateur complète

---

# Dans le cycle en spirale, chaque tour de spirale:
- [ ] Représente une phase du projet
- [x] Représente une itération incluant analyse de risques
- [ ] Doit durer exactement 1 mois
- [ ] Est identique au précédent

---

# La Gestion de Configuration et Changements vise principalement à:
- [ ] Augmenter la documentation
- [ ] Ralentir les changements
- [x] Contrôler l'évolution des artefacts de manière systématique
- [ ] Empêcher les modifications au code

---

# Quelle affirmation est VRAIE sur le refactoring?
- [ ] On devrait refactorer avant d'écrire les tests
- [ ] Le refactoring change le comportement externe du code
- [x] On devrait toujours refactorer quand les tests passent
- [ ] Le refactoring devrait être fait une fois par mois

---

# Un risque technique affecte principalement:
- [ ] L'échéancier du projet
- [x] La qualité du produit
- [ ] Le budget uniquement
- [ ] Les relations avec le client

---

# Dans le Processus Unifié, quelle phase établit l'architecture de base?
- [ ] Création
- [x] Élaboration
- [ ] Construction
- [ ] Transition

---

# L'architecture logicielle devrait être définie:
- [ ] À la toute fin du projet
- [ ] Pendant la phase de Construction
- [x] Tôt dans le projet (phase d'Élaboration)
- [ ] Après avoir écrit tout le code

---

# Quelle affirmation est FAUSSE sur les parties prenantes?
- [ ] Elles incluent les utilisateurs finaux
- [ ] Elles incluent les développeurs
- [x] Seul le client payeur est une partie prenante
- [ ] Elles peuvent inclure des régulateurs

---

# Les trois dimensions de la GCC sont:
- [ ] Code, Tests, Documentation
- [x] Gestion des versions, Gestion des changements, Gestion des builds
- [ ] Personnes, Processus, Technologie
- [ ] Développement, Staging, Production

---

# En Property-Based Testing, on teste:
- [ ] Les propriétés CSS de l'interface
- [ ] Des cas spécifiques prédéfinis
- [x] Des propriétés générales avec des cas générés aléatoirement
- [ ] Seulement les variables publiques

---

# Un processus itératif permet de:
- [ ] Éviter complètement les changements d'exigences
- [ ] Éliminer tous les risques dès le début
- [x] Adapter et apprendre progressivement à chaque itération
- [ ] Réduire la documentation à zéro

---

# Dans la structure 3A (Arrange-Act-Assert), on devrait avoir:
- [ ] Autant d'assertions que possible pour tout tester
- [x] Idéalement une seule assertion logique par test
- [ ] Aucune assertion (le test échoue automatiquement)
- [ ] Les assertions seulement dans le Arrange

---

# Le Plan de développement logiciel (SDL) contient:
- [ ] Seulement le code source du projet
- [ ] Seulement la liste des risques
- [x] Plan de mesure, plan d'itération, liste des risques et plus
- [ ] Seulement le calendrier des itérations

---

# Quelle affirmation est VRAIE sur les tests?
- [ ] Les tests créent la qualité du logiciel
- [x] Les tests révèlent ou confirment la qualité existante
- [ ] Plus on teste, meilleur est le logiciel automatiquement
- [ ] Les tests remplacent le besoin d'une bonne architecture

---

# Pour 3 fonctions avec 5, 7 et 3 cas respectivement, combien de tests d'intégration faut-il pour tout couvrir?
- [ ] 15 tests
- [ ] 35 tests
- [x] 105 tests
- [ ] 21 tests

---

# Un anti-pattern du déploiement continu est:
- [ ] Déployer plusieurs fois par semaine
- [ ] Automatiser les tests
- [x] Déployer en production seulement à la fin du projet
- [ ] Utiliser un environnement de staging

---

# Le rôle principal de l'intégrateur est de:
- [ ] Écrire tous les tests unitaires
- [ ] Gérer le budget du projet
- [x] Planifier et réaliser l'intégration des composants
- [ ] Réviser le code de toute l'équipe

---

# Quelle est la fréquence minimale pour identifier et analyser les risques?
- [ ] Une fois au début du projet
- [ ] Une fois par phase
- [x] Continuellement tout au long du projet
- [ ] Seulement quand un problème survient

---

# Dans un système de gestion de version centralisé:
- [ ] Chaque développeur a l'historique complet
- [x] L'historique est seulement sur le serveur central
- [ ] On ne peut pas faire de branches
- [ ] C'est toujours meilleur qu'un système distribué

---

# Les tests automatisés en déploiement continu doivent:
- [ ] Être exécutés manuellement avant chaque déploiement
- [ ] Être optionnels si l'équipe est expérimentée
- [x] Être exécutés automatiquement dans le pipeline
- [ ] Remplacer complètement les tests manuels

---

# Une exigence non-fonctionnelle porte sur:
- [ ] Les fonctionnalités du système
- [x] Comment le système doit être (performance, sécurité, etc.)
- [ ] Ce que le système ne doit pas faire
- [ ] Les fonctions qui ne sont pas implémentées

---

# Quel jalon termine la phase de Construction?
- [ ] LCO
- [ ] LCA
- [x] IOC (Initial Operational Capability)
- [ ] Aucun jalon ne termine Construction

---

# Explanations

# Question 1
L'étape de Turbulence (Storming) est celle où les conflits émergent naturellement. C'est une étape normale et saine où les membres de l'équipe expriment leurs désaccords, testent les limites et établissent leur place dans l'équipe. Sans cette étape, l'équipe ne peut pas atteindre la vraie performance.

# Question 2
Les tests unitaires font partie de la discipline d'implémentation, pas de la discipline des tests. Ils sont écrits par les développeurs en même temps que le code, testent la traduction de la conception en code, et sont exécutés avant l'intégration. La discipline des tests concerne les tests planifiés et conçus (intégration, système, acceptation).

# Question 3
Le jalon LCA (Lifecycle Architecture) marque la fin de la phase d'Élaboration. À ce moment, l'architecture du système est établie et validée. LCO termine la Création, IOC termine la Construction, et PR termine la Transition.

# Question 4
Dans Git, le référentiel (repository) est la base de données versionnée qui contient tous les éléments de configuration, leur historique complet, et toutes les métadonnées. Ce n'est pas juste un document ou une branche, c'est toute la structure de stockage.

# Question 5
L'affirmation fausse est que les tests unitaires testent l'intégration entre plusieurs composants. C'est exactement le contraire : les tests unitaires testent UNE SEULE unité en ISOLATION, en utilisant des mocks pour éliminer les dépendances. Ce sont les tests d'intégration qui testent les interactions entre composants.

# Question 6
En intégration continue, 100% des tests doivent passer. Pas 95%, pas 98%, mais 100%. Même un seul test qui échoue signifie que le build est cassé et doit être réparé immédiatement avant toute autre activité. C'est une règle absolue.

# Question 7
La pyramide des tests indique qu'on devrait avoir beaucoup de tests unitaires (base large), quelques tests d'intégration (milieu), et peu de tests de système (sommet). Mathématiquement, cela permet de couvrir plus de cas avec moins de tests.

# Question 8
Un risque de projet affecte principalement le déroulement et l'échéancier du projet : perte d'employé, retard de matériel, changement de gestion, etc. Les risques techniques affectent la qualité du produit, et les risques d'affaire affectent l'organisation dans son ensemble.

# Question 9
Dans le cycle en cascade, comme chaque phase doit être complète avant de passer à la suivante, les problèmes majeurs sont souvent découverts tard pendant les tests. À ce moment, il est très coûteux de revenir en arrière pour corriger des décisions prises en analyse ou conception.

# Question 10
Un processus cérémonieux a effectivement beaucoup de formalisme et de documentation détaillée (comme RUP complet). Ce n'est ni mieux ni pire qu'un processus opportuniste (agile) - le choix dépend du contexte, de la taille du projet, et des exigences réglementaires.

# Question 11
"Done means released" signifie que le travail n'est vraiment terminé que lorsqu'il est déployé en production et accessible aux utilisateurs finaux. Avoir le code écrit, testé ou même en staging ne suffit pas - la valeur n'est générée que quand les utilisateurs peuvent l'utiliser.

# Question 12
La stratégie "Transférer" consiste à faire supporter le risque par quelqu'un d'autre, par exemple en sous-traitant une partie risquée du projet, en achetant de l'assurance, ou en utilisant un composant externe plutôt que de le développer.

# Question 13
Dans la phase de Construction, c'est là qu'on réalise la majorité des tests planifiés (tests d'intégration, système, acceptation). Bien que les tests soient présents dans toutes les phases, leur intensité est maximale en Construction.

# Question 14
Une contrainte est une limitation imposée au projet : budget maximum, technologie obligatoire, réglementation à respecter, plateforme imposée, etc. C'est différent des exigences fonctionnelles (ce que le système fait) et non-fonctionnelles (comment il le fait).

# Question 15
Le Design by Contract définit explicitement les préconditions (ce qui doit être vrai avant l'exécution d'une méthode), les postconditions (ce qui doit être vrai après), et les invariants (ce qui doit toujours être vrai pour une classe). Ce n'est pas lié aux contrats légaux.

# Question 16
Les tests unitaires testent principalement le comportement logique d'une seule unité (classe, méthode) en isolation. Ils ne testent pas l'intégration, ni la conformité directe aux besoins du client (c'est le rôle des tests d'acceptation), ni les interactions avec la base de données.

# Question 17
L'affirmation fausse est qu'on peut commiter du code qui ne compile pas. En intégration continue, on ne doit JAMAIS commiter du code qui ne compile pas ou dont les tests échouent. On garde pour soi le code cassé.

# Question 18
Un facteur de risque est l'origine ou la cause d'un ou plusieurs risques. Par exemple, "nouvelle technologie" est un facteur de risque qui peut causer plusieurs risques : manque de compétences, bugs imprévus, problèmes de performance. Ce n'est pas le risque lui-même mais sa source.

# Question 19
Le plan d'itération est le plan détaillé (niveau intra-itération) qui couvre UNE SEULE itération, typiquement 2-4 semaines. Le plan du projet (niveau grossier) couvre toute la durée du projet avec une vision de 6-12 mois.

# Question 20
Les mocks permettent d'isoler complètement l'unité testée de ses dépendances en les remplaçant par des objets simulés contrôlables. Ils sont utilisés dans les tests unitaires uniquement, pas dans les tests d'intégration qui testent les vraies interactions.

# Question 21
L'analyse se concentre sur QUOI faire (comprendre le problème, identifier les besoins), tandis que la conception se concentre sur COMMENT le faire (définir la solution, l'architecture, les technologies). L'analyse est orientée problème, la conception orientée solution.

# Question 22
Les tests d'acceptation vérifient que le système répond aux besoins du client et aux exigences fonctionnelles. Ils sont écrits du point de vue de l'utilisateur et valident des scénarios d'utilisation complets. Ils ne testent pas que le code compile ou la performance spécifiquement.

# Question 23
Dans un système distribué comme Git, chaque développeur possède une copie complète de l'historique du projet sur sa machine locale. Cela permet de travailler hors ligne, de voir tout l'historique, et offre une meilleure résilience.

# Question 24
Les bases de référence ne doivent PAS être créées après chaque commit - ce serait excessif. Elles sont créées à des moments clés du projet (fin d'itération, livraison, jalons importants) pour marquer des configurations stables et approuvées.

# Question 25
Le cycle transformationnel convient aux projets de recherche où il y a beaucoup d'incertitude. On part d'une spécification formelle et on la transforme progressivement en implémentation par raffinements successifs. C'est approprié quand on explore de nouvelles solutions.

# Question 26
En TDD, l'ordre est : 1) Écrire un test qui échoue (Rouge - la fonctionnalité n'existe pas encore), 2) Écrire le code minimum pour faire passer le test (Vert), 3) Refactorer le code (Bleu) pour améliorer sa structure. Ce cycle garantit que tout le code est testé.

# Question 27
Les tests d'acceptation avec Cucumber utilisent le format Given-When-Then avec le langage Gherkin. Given décrit les préconditions, When l'action effectuée, Then le résultat attendu. Ce format est compréhensible par tous, y compris les non-techniques.

# Question 28
Le triangle de fer montre que les trois dimensions (Qualité, Temps, Coût) sont interdépendantes. Si on réduit le temps, il faut soit augmenter le coût (plus de ressources) et/ou réduire la qualité (moins de fonctionnalités ou qualité moindre). On ne peut pas améliorer une dimension sans affecter les autres.

# Question 29
Une itération est réussie seulement quand TOUS les critères sont atteints : tous les risques minimisés, toutes les fonctionnalités réalisées, et tous les objectifs de qualité atteints. 90% n'est pas suffisant - c'est tout ou rien.

# Question 30
En déploiement continu, les déploiements doivent être automatisés et fréquents. Il ne faut pas nécessairement déployer après chaque commit (cela dépend du contexte), et l'environnement de staging reste important. Le déploiement continu convient à tous types d'organisations, pas seulement les startups.

# Question 31
Le staging sert à tester dans des conditions aussi similaires que possible à la production avant de déployer réellement. Cela permet de détecter des problèmes de configuration ou d'environnement qui ne seraient pas visibles en développement.

# Question 32
L'affirmation fausse est qu'un risque avec probabilité faible ne nécessite jamais d'action. Si un risque a une probabilité faible mais un impact catastrophique (perte × probabilité), il peut quand même être prioritaire et nécessiter des actions de mitigation.

# Question 33
Les disciplines d'ingénierie dans le Processus Unifié sont : Exigences (Requis), Analyse & Conception, Implémentation, et Tests. Les disciplines de support incluent la Gestion de Projet et la Gestion de Configuration. Les phases sont Création, Élaboration, Construction, Transition.

# Question 34
Un élément de configuration peut être un fichier individuel, un répertoire complet, ou un module entier. Dans Git, n'importe quel ensemble d'artefacts peut être traité comme un élément de configuration s'il est versionné et tracé.

# Question 35
Une itération typique dans le Processus Unifié dure 2-4 semaines. C'est assez court pour permettre un feedback rapide, mais assez long pour livrer quelque chose de significatif. 1 jour ou 1 semaine serait trop court, 2-3 mois serait trop long et perdrait les avantages de l'itératif.

# Question 36
Les tests unitaires selon Design by Contract testent les préconditions (les paramètres sont valides), les postconditions (le résultat est correct), et les invariants de classe (l'état de l'objet reste cohérent). Ils ne testent pas les interfaces utilisateur ou les intégrations.

# Question 37
Un besoin exprime un problème du point de vue utilisateur (QUOI), tandis qu'une exigence est une solution ou capacité spécifique du système (COMMENT). Un besoin peut se traduire en plusieurs exigences. C'est une distinction importante pour bien comprendre le problème avant de concevoir la solution.

# Question 38
Avant de faire un push en intégration continue, on devrait intégrer et tester dans son espace privé d'abord. Cela signifie récupérer les derniers changements du dépôt, les intégrer localement, et s'assurer que tout compile et que tous les tests passent avant de pousser.

# Question 39
KISS (Keep It Simple, Stupid) signifie qu'on devrait garder la conception simple et éviter la sur-conception. On ne doit pas ajouter de complexité inutile ou implémenter des fonctionnalités "au cas où". Il faut implémenter ce qui est nécessaire maintenant, pas ce qui pourrait être nécessaire plus tard.

# Question 40
L'affirmation fausse est que les tests de système sont les plus importants. En réalité, tous les niveaux de tests sont importants mais pour des raisons différentes. Les tests de système testent tout mais sont lents et difficiles à déboguer. Les tests unitaires sont tout aussi importants car ils couvrent plus de cas rapidement et sont faciles à déboguer.

# Question 41
Un test d'intégration utilise les vraies instances des composants testés, pas des mocks. C'est ce qui le distingue du test unitaire. Le but est de tester les vraies interactions entre composants réels pour détecter les problèmes d'intégration.

# Question 42
Dans le cycle en spirale, chaque tour représente une itération qui inclut obligatoirement une analyse de risques. C'est ce qui distingue la spirale des autres cycles itératifs - l'accent mis sur l'identification et la gestion proactive des risques à chaque tour.

# Question 43
La GCC vise à contrôler l'évolution des artefacts de manière systématique. Ce n'est pas pour ralentir les changements ou empêcher les modifications, mais pour les gérer de façon ordonnée : savoir qui a changé quoi, quand, pourquoi, et pouvoir revenir en arrière si nécessaire.

# Question 44
On devrait refactorer quand les tests passent. Le refactoring améliore la structure interne du code sans changer son comportement externe. Les tests qui passent garantissent qu'on ne casse rien pendant le refactoring. Refactorer du code cassé ou sans tests est dangereux.

# Question 45
Un risque technique affecte principalement la qualité du produit : problèmes de performance, outils qui ne fonctionnent pas comme prévu, composants défectueux, limitations techniques. Les risques de projet affectent l'échéancier, les risques d'affaire affectent l'organisation.

# Question 46
L'architecture de base est établie pendant la phase d'Élaboration. C'est l'objectif principal de cette phase. En Création, on explore seulement la faisabilité. En Construction, on implémente selon l'architecture déjà définie. Définir l'architecture trop tard serait risqué.

# Question 47
L'architecture devrait être définie tôt dans le projet, pendant la phase d'Élaboration. Les décisions architecturales sont difficiles et coûteuses à changer plus tard. Il faut les prendre tôt, les valider avec un prototype si nécessaire, puis les raffiner progressivement.

# Question 48
L'affirmation fausse est que seul le client payeur est une partie prenante. En réalité, toute personne ou organisation affectée par le système ou qui peut l'influencer est une partie prenante : utilisateurs, développeurs, gestionnaires, régulateurs, fournisseurs, etc.

# Question 49
Les trois dimensions de la GCC sont : Gestion des versions (tracking des changements), Gestion des changements (processus pour demander/approuver modifications), et Gestion des builds (compilation et assemblage automatiques). Ce ne sont pas juste des environnements.

# Question 50
Le Property-Based Testing teste des propriétés générales que le code doit toujours respecter (comme "Math.abs(x) >= 0 pour tout x"), et la bibliothèque génère automatiquement des cas de test aléatoires pour tenter de violer la propriété. C'est différent des tests traditionnels qui testent des cas spécifiques prédéfinis.

# Question 51
Un processus itératif permet d'adapter et d'apprendre progressivement à chaque itération. Il ne peut pas éviter complètement les changements (au contraire, il les accueille), ni éliminer tous les risques dès le début, ni réduire la documentation à zéro (elle reste nécessaire mais adaptée).

# Question 52
Dans la structure 3A, on devrait idéalement avoir une seule assertion logique par test (Single Responsibility). Une assertion logique peut correspondre à plusieurs instructions assert dans le code, mais devrait tester un seul concept. Trop d'assertions rendent le test difficile à déboguer.

# Question 53
Le SDL (Software Development Plan) est l'ensemble complet d'artefacts pour gérer le projet. Il contient le plan de mesure (métriques à suivre), le plan d'itération (tâches détaillées), la liste des risques et leurs stratégies de mitigation, et d'autres documents de planification et suivi.

# Question 54
Les tests révèlent ou confirment la qualité existante, ils ne la créent pas. La qualité doit être construite dans le produit dès le départ (architecture, conception, code propre). Les tests permettent de vérifier que cette qualité est bien présente, mais ne peuvent pas la créer après coup.

# Question 55
Pour 3 fonctions avec 5, 7 et 3 cas, tester par intégration nécessite de tester toutes les combinaisons : 5 × 7 × 3 = 105 tests. Tester unitairement nécessite seulement 5 + 7 + 3 = 15 tests. C'est pourquoi les tests unitaires sont plus efficaces pour couvrir tous les cas.

# Question 56
Un anti-pattern du déploiement continu est de déployer en production seulement à la fin du projet. Cela introduit des risques : découverte tardive de problèmes d'infrastructure, stress élevé, difficultés de rollback, peu de pratique du processus. Il faut déployer fréquemment dès le début.

# Question 57
L'intégrateur est responsable de planifier l'intégration des différents composants développés par les implémenteurs, de réaliser cette intégration, de gérer les dépendances entre modules, et de coordonner le travail. Il s'assure que les composants fonctionnent bien ensemble et produit les builds.

# Question 58
L'identification et l'analyse des risques doivent être faites continuellement tout au long du projet, pas juste une fois au début. Les risques évoluent : certains disparaissent, de nouveaux apparaissent, les priorités changent. Il faut les surveiller et les réévaluer régulièrement.

# Question 59
Dans un système centralisé (comme SVN), l'historique complet est seulement sur le serveur central. Les développeurs ont une copie de travail mais pas l'historique. Cela les rend dépendants du serveur et rend certaines opérations plus lentes. Git (distribué) donne l'historique complet à chacun.

# Question 60
Les tests automatisés en déploiement continu doivent être exécutés automatiquement dans le pipeline de déploiement. Ils ne peuvent pas être manuels (trop lent et sujet aux erreurs), et ils ne sont pas optionnels même pour une équipe expérimentée. L'automatisation est essentielle.

# Question 61
Une exigence non-fonctionnelle porte sur COMMENT le système doit être (ses qualités) plutôt que sur ce qu'il fait. Elle concerne la performance, la sécurité, l'utilisabilité, la fiabilité, la maintenabilité, etc. Les exigences fonctionnelles décrivent ce que le système fait.

# Question 62
Le jalon IOC (Initial Operational Capability) marque la fin de la phase de Construction. À ce moment, le système est suffisamment complet et stable pour être déployé dans l'environnement des utilisateurs. Il reste la phase de Transition pour le déploiement final et les ajustements.