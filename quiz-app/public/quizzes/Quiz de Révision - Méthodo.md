# Quel est le principal avantage d'utiliser un processus logiciel dans un projet de développement?
- [ ] Il garantit que le projet sera livré à temps
- [x] Il permet de gérer la complexité du projet
- [ ] Il élimine tous les bugs du logiciel
- [ ] Il réduit le coût du projet de 50%

---

# Quelles sont les étapes de construction d'une équipe dans le bon ordre?
- [ ] Forming, Storming, Norming, Performing, Adjourning
- [x] Formation, Turbulence, Normalisation, Performance, Dissolution
- [ ] Normalisation, Formation, Performance, Turbulence, Dissolution
- [ ] Performance, Formation, Normalisation, Turbulence, Dissolution

---

# Qu'est-ce qu'une équipe maillée?
- [ ] Une équipe où chaque membre travaille de manière isolée
- [ ] Une équipe dirigée par un leader autoritaire
- [x] Une équipe auto-organisée où le leadership est distribué
- [ ] Une équipe qui n'a pas besoin de communication

---

# Quelle est la différence principale entre un projet et un produit physique en génie logiciel?
- [ ] Le projet logiciel coûte toujours plus cher
- [x] L'extrant du projet logiciel est moins tangible
- [ ] Le projet logiciel ne nécessite pas de planification
- [ ] Le projet logiciel n'a pas de contraintes de temps

---

# Qu'est-ce qu'un cycle de vie en développement logiciel?
- [ ] La durée de vie d'un logiciel en production
- [x] L'ensemble des phases par lesquelles passe un projet de développement
- [ ] Le temps nécessaire pour écrire le code
- [ ] La période entre deux versions du logiciel

---

# Dans le cycle de vie en cascade, quel est le principal inconvénient?
- [ ] Il est trop rapide
- [ ] Il nécessite trop de documentation
- [x] Les changements sont difficiles et coûteux une fois une phase terminée
- [ ] Il ne permet pas de tester le logiciel

---

# Quelles sont les quatre phases du Processus Unifié dans le bon ordre?
- [ ] Élaboration, Création, Construction, Transition
- [x] Création, Élaboration, Construction, Transition
- [ ] Construction, Création, Élaboration, Transition
- [ ] Transition, Construction, Élaboration, Création

---

# Quel jalon marque la fin de la phase de Création?
- [ ] LCA (Lifecycle Architecture)
- [x] LCO (Lifecycle Objectives)
- [ ] IOC (Initial Operational Capability)
- [ ] PR (Product Release)

---

# Qu'est-ce qu'une itération dans le Processus Unifié?
- [ ] Une réunion d'équipe hebdomadaire
- [ ] Une phase complète du projet
- [x] Un mini-projet qui produit un incrément du système
- [ ] Un cycle de tests automatisés

---

# Quelle est la principale caractéristique d'un processus agile?
- [ ] Il nécessite beaucoup de documentation
- [x] Il privilégie l'adaptation au changement
- [ ] Il suit strictement un plan initial
- [ ] Il évite toute communication avec le client

---

# Quel est l'objectif principal de la discipline de Gestion de Configuration et Changements?
- [ ] Créer plus de documentation
- [x] Contrôler l'évolution des artefacts du projet
- [ ] Augmenter le nombre de réunions
- [ ] Réduire le nombre de développeurs

---

# Qu'est-ce qu'un élément de configuration?
- [ ] Un fichier de configuration du serveur
- [x] Un artefact ou agrégat d'artefacts traité comme une entité unique
- [ ] Une ligne de code
- [ ] Un ordinateur de l'équipe

---

# Quelle est la différence entre un système de gestion de version centralisé et distribué?
- [x] Dans un système distribué, chaque développeur a une copie complète de l'historique
- [ ] Un système centralisé est plus rapide
- [ ] Un système distribué ne permet pas de collaboration
- [ ] Il n'y a aucune différence

---

# Qu'est-ce qu'une base de référence (baseline)?
- [ ] La première version du code
- [x] Un ensemble d'éléments de configuration formant une configuration stable à un moment donné
- [ ] Le code du serveur de production
- [ ] La documentation du projet

---

# Quelle est la différence entre un besoin et une exigence?
- [ ] Il n'y a pas de différence
- [x] Un besoin exprime un problème, une exigence exprime une solution
- [ ] Une exigence est toujours technique
- [ ] Un besoin est documenté, pas une exigence

---

# Quels sont les trois types d'exigences en génie logiciel?
- [ ] Simples, complexes, moyennes
- [x] Fonctionnelles, non-fonctionnelles, contraintes
- [ ] Techniques, business, utilisateur
- [ ] Primaires, secondaires, tertiaires

---

# Qu'est-ce qu'une partie prenante?
- [ ] Un actionnaire de l'entreprise
- [ ] Un développeur du projet
- [x] Toute personne ou organisation affectée par le système
- [ ] Le chef de projet uniquement

---

# Pourquoi est-il important d'établir une traçabilité entre exigences et tests?
- [ ] Pour augmenter la documentation
- [x] Pour s'assurer que toutes les exigences sont testées et validées
- [ ] Pour réduire le nombre de tests
- [ ] Pour accélérer le développement

---

# Quelle est la principale différence entre analyse et conception?
- [x] L'analyse se concentre sur QUOI faire, la conception sur COMMENT le faire
- [ ] L'analyse est plus difficile que la conception
- [ ] La conception vient toujours avant l'analyse
- [ ] Il n'y a pas de différence

---

# Qu'est-ce qu'une architecture logicielle?
- [ ] Le design de l'interface utilisateur
- [ ] La liste de toutes les classes du système
- [x] L'organisation fondamentale du système et ses principes directeurs
- [ ] Le diagramme de base de données

---

# Quel est un bénéfice clé d'une bonne architecture?
- [ ] Elle élimine tous les bugs
- [ ] Elle réduit le nombre de lignes de code
- [x] Elle facilite la maintenabilité et l'évolution du système
- [ ] Elle accélère l'écriture du code initial

---

# Pourquoi utilise-t-on des modèles en analyse et conception?
- [ ] Pour impressionner le client
- [ ] Parce que c'est obligatoire
- [x] Pour communiquer et comprendre le système avant de le construire
- [ ] Pour remplacer la documentation

---

# Quelles sont les quatre compétences de base en implémentation?
- [ ] Lire, écrire, compiler, exécuter
- [x] Programmer, Déboguer, Tester unitairement, Intégrer
- [ ] Analyser, concevoir, coder, tester
- [ ] Planifier, coder, déployer, maintenir

---

# Quelle compétence permet d'enlever les fautes de traduction?
- [ ] Programmer
- [ ] Déboguer
- [x] Exécuter des tests unitaires
- [ ] Intégrer

---

# Qu'est-ce qu'un test unitaire?
- [ ] Un test qui vérifie tout le système
- [x] Un bout de code automatisé qui teste une unité en isolation
- [ ] Un test manuel fait par un testeur
- [ ] Un test d'acceptation du client

---

# Que signifie le principe F.I.R.S.T. pour les tests unitaires?
- [ ] First In Right Software Testing
- [x] Fast, Independent, Repeatable, Self-validating, Timely
- [ ] Function Integration Regression System Test
- [ ] Functional Integrated Robust Stable Testable

---

# Quelle est la fréquence minimale recommandée pour l'intégration continue?
- [ ] Une fois par semaine
- [x] Au moins une fois par jour
- [ ] Une fois par mois
- [ ] Seulement à la fin de chaque itération

---

# Quel pourcentage de tests doit réussir en intégration continue?
- [ ] 80%
- [ ] 90%
- [ ] 95%
- [x] 100%

---

# Que doit-on faire si le build d'intégration continue échoue?
- [ ] Continuer à travailler normalement
- [ ] Attendre la fin de la journée pour le réparer
- [x] Réparer immédiatement ou aider à réparer
- [ ] Créer un ticket et passer à autre chose

---

# Quelle est la principale différence entre un test unitaire et un test d'intégration?
- [ ] Le test unitaire est plus long
- [x] Le test unitaire utilise des mocks, pas le test d'intégration
- [ ] Le test d'intégration est automatisé, pas le test unitaire
- [ ] Il n'y a pas de différence

---

# Les tests unitaires font-ils partie de la discipline de tests dans le Processus Unifié?
- [x] Non, ils font partie de la discipline d'implémentation
- [ ] Oui, ils font partie de la discipline de tests
- [ ] Ils ne font partie d'aucune discipline
- [ ] Ils font partie de la discipline d'analyse

---

# Que teste un test de système (end-to-end)?
- [ ] Une seule classe
- [ ] Deux composants qui interagissent
- [x] Le système complet de l'interface à la base de données
- [ ] Uniquement la base de données

---

# Quel format utilisent les tests d'acceptation avec Cucumber?
- [ ] Arrange-Act-Assert
- [x] Given-When-Then
- [ ] Setup-Execute-Verify
- [ ] Before-During-After

---

# Selon la pyramide des tests, quelle devrait être la proportion des différents types de tests?
- [ ] Plus de tests système que d'unitaires
- [x] Beaucoup d'unitaires, quelques intégrés, peu de système
- [ ] Autant de chaque type
- [ ] Seulement des tests système

---

# Pourquoi devrait-on avoir plus de tests unitaires que de tests intégrés?
- [ ] Les tests unitaires sont plus faciles à écrire
- [ ] Les tests intégrés coûtent plus cher
- [x] Les tests unitaires couvrent plus de cas avec moins de tests
- [ ] C'est une convention arbitraire

---

# Les tests créent-ils de la qualité dans un logiciel?
- [x] Non, ils la confirment ou la révèlent
- [ ] Oui, plus on teste, plus le logiciel est de qualité
- [ ] Oui, mais seulement les tests automatisés
- [ ] Cela dépend du type de tests

---

# Qu'est-ce qu'un processus décrit?
- [ ] Seulement qui fait quoi
- [ ] Seulement comment faire les choses
- [x] QUI fait QUOI, COMMENT et QUAND
- [ ] Uniquement l'ordre des activités

---

# Quelles sont les trois dimensions interdépendantes d'un projet?
- [ ] Personnes, Processus, Technologie
- [x] Qualité, Temps, Coût
- [ ] Analyse, Conception, Implémentation
- [ ] Client, Équipe, Produit

---

# Quelle est une particularité des projets logiciel par rapport aux autres projets?
- [ ] Ils sont toujours plus longs
- [x] La nature intellectuelle du travail rend difficile la mesure de l'avancement
- [ ] Ils ne nécessitent pas de planification
- [ ] Ils n'ont pas de contraintes budgétaires

---

# Qu'est-ce que la planification à deux niveaux?
- [ ] Planifier pour deux équipes différentes
- [x] Plan du projet (grossier) et Plan d'itération (détaillé)
- [ ] Planifier deux fois la même chose
- [ ] Un plan technique et un plan financier

---

# Qu'est-ce qu'un risque en gestion de projet?
- [ ] Un problème qui s'est déjà produit
- [x] Une variable dont la valeur peut mettre en danger le succès du projet
- [ ] Une tâche difficile à réaliser
- [ ] Un membre d'équipe problématique

---

# Quelle est la formule du risque?
- [ ] RISQUE = PROBABILITÉ + IMPACT
- [x] RISQUE = INCERTITUDE × PERTE
- [ ] RISQUE = COÛT × TEMPS
- [ ] RISQUE = COMPLEXITÉ / RESSOURCES

---

# Quelles sont les quatre étapes de la démarche de maîtrise des risques?
- [ ] Trouver, Analyser, Résoudre, Documenter
- [x] Identifier, Analyser, Se préparer, Surveiller
- [ ] Détecter, Évaluer, Corriger, Prévenir
- [ ] Lister, Prioriser, Mitiger, Fermer

---

# Quelles sont les cinq stratégies de préparation aux risques?
- [ ] Accepter, Ignorer, Reporter, Déléguer, Résoudre
- [x] Éviter, Transférer, Accepter, Atténuer, Plan B
- [ ] Identifier, Analyser, Traiter, Surveiller, Clore
- [ ] Prévenir, Détecter, Corriger, Accepter, Documenter

---

# Qu'est-ce qu'un risque de processus?
- [ ] Le risque que le processus soit trop long
- [ ] Le risque que l'équipe refuse le processus
- [x] Un risque lié aux pratiques du génie logiciel utilisées par l'équipe
- [ ] Le risque que le processus change en cours de projet

---

# Qu'est-ce que le déploiement continu?
- [ ] Déployer une fois par an
- [ ] Déployer seulement quand tout est prêt
- [x] Livraisons fréquentes par déploiements automatisés
- [ ] Déployer manuellement à chaque changement

---

# Quels sont les trois environnements du logiciel en déploiement continu?
- [ ] Local, Test, Production
- [x] Développement, Staging, Production
- [ ] Dev, QA, Prod
- [ ] Alpha, Beta, Release

---

# Quel est l'environnement Staging?
- [ ] L'environnement de développement local
- [ ] L'environnement de production
- [x] Un environnement simulé aussi similaire que possible à la production
- [ ] Un environnement de tests unitaires

---

# Quels sont les trois objectifs du pipeline de déploiement?
- [ ] Rapidité, Qualité, Sécurité
- [x] Visibilité totale, Rétroaction rapide, Capacité de déploiement à volonté
- [ ] Automatisation, Documentation, Validation
- [ ] Tests, Intégration, Livraison

---

# Que signifie "Done means released"?
- [ ] Le code est écrit
- [ ] Les tests passent
- [x] Terminé signifie déployé en production
- [ ] La documentation est complète

---

# Quel est un anti-pattern du déploiement continu?
- [ ] Déployer trop souvent
- [x] Déployer manuellement avec documentation complexe
- [ ] Avoir un environnement de staging
- [ ] Automatiser les tests

---

# Pourquoi devrait-on déployer fréquemment même si c'est difficile?
- [ ] Pour impressionner le client
- [ ] C'est une mode dans l'industrie
- [x] Plus on pratique, plus ça devient facile et moins stressant
- [ ] Pour trouver des bugs plus rapidement

---

# Quel est le cycle de vie le plus adapté pour un projet avec des exigences bien définies et stables?
- [x] Cascade
- [ ] Spirale
- [ ] Transformationnel
- [ ] Agile

---

# Dans un cycle de vie incrémental, que livre-t-on à chaque incrément?
- [ ] De la documentation
- [ ] Des plans de test
- [x] Une partie fonctionnelle du système
- [ ] Du code non testé

---

# Qu'est-ce qui distingue un processus cérémonieux d'un processus opportuniste?
- [ ] Le nombre de développeurs
- [ ] Le budget du projet
- [x] Le niveau de formalisme et de documentation
- [ ] La durée du projet

---

# Quelles sont les trois dimensions de la Gestion de Configuration et Changements?
- [ ] Personnes, Processus, Outils
- [x] Gestion des versions, Gestion des changements, Gestion des builds
- [ ] Code, Tests, Documentation
- [ ] Développement, Staging, Production

---

# Pourquoi établir des bases de référence dans un référentiel?
- [ ] Pour occuper de l'espace disque
- [ ] C'est une obligation légale
- [x] Pour marquer des configurations stables et pouvoir y revenir
- [ ] Pour créer plus de branches

---

# Qu'est-ce qu'une exigence fonctionnelle?
- [ ] Une exigence qui fonctionne bien
- [x] Une exigence qui décrit ce que le système doit faire
- [ ] Une exigence technique
- [ ] Une exigence liée à la performance

---

# Qu'est-ce qu'une exigence non-fonctionnelle?
- [ ] Une exigence qui ne fonctionne pas
- [ ] Une exigence optionnelle
- [x] Une exigence qui décrit comment le système doit être (performance, sécurité, etc.)
- [ ] Une exigence rejetée par le client

---

# Quel est l'avantage d'un processus itératif pour la gestion des exigences?
- [ ] On n'a pas besoin de documenter les exigences
- [ ] Les exigences ne changent jamais
- [x] On peut adapter les exigences à chaque itération selon les apprentissages
- [ ] On peut ignorer les exigences du client

---

# Qu'est-ce que le Design by Contract?
- [ ] Un contrat légal entre développeurs
- [ ] Un patron de conception
- [x] Une approche définissant préconditions, postconditions et invariants
- [ ] Une méthodologie de gestion de projet

---

# Quel type de diagramme UML est utilisé pour modéliser la structure statique?
- [ ] Diagramme de séquence
- [x] Diagramme de classes
- [ ] Diagramme d'activités
- [ ] Diagramme de cas d'utilisation

---

# Que teste-t-on dans les tests unitaires selon le Design by Contract?
- [ ] L'interface utilisateur
- [ ] La base de données
- [x] Les préconditions, postconditions et invariants de classe
- [ ] La performance du système

---

# Qu'est-ce que la structure Arrange-Act-Assert (3A)?
- [ ] Une architecture logicielle
- [ ] Un patron de conception
- [x] Une structure pour organiser les tests unitaires
- [ ] Une méthode de planification

---

# Pourquoi utiliser des Mocks dans les tests unitaires?
- [ ] Pour rendre les tests plus lents
- [ ] Pour tester le système complet
- [x] Pour isoler l'unité testée de ses dépendances
- [ ] Pour remplacer la base de données en production

---

# Quelle est la règle d'or lors du refactoring?
- [ ] Ne jamais refactorer
- [ ] Refactorer sans tests
- [x] Toujours refactorer avec des tests qui passent
- [ ] Refactorer seulement à la fin du projet

---

# Que signifie KISS en développement logiciel?
- [ ] Keep It Super Simple
- [x] Keep It Simple, Stupid
- [ ] Keep Implementing Simple Solutions
- [ ] Keep Iterations Short and Simple

---

# Quelle est une pratique essentielle de l'intégration continue?
- [ ] Faire un commit une fois par mois
- [ ] Ne jamais faire de commit si le code ne compile pas
- [x] Faire des commits fréquents et réparer immédiatement les builds cassés
- [ ] Tester manuellement avant chaque commit

---

# Qu'est-ce que le TDD (Test-Driven Development)?
- [ ] Tester après avoir écrit le code
- [x] Écrire les tests avant d'écrire le code
- [ ] Ne jamais écrire de tests
- [ ] Tester seulement à la fin du projet

---

# Pourquoi évaluer les tests?
- [ ] Pour critiquer les testeurs
- [ ] C'est une perte de temps
- [x] Pour garantir que les tests sont de qualité et couvrent les aspects cruciaux
- [ ] Pour augmenter le nombre de tests

---

# Qu'est-ce que le Property-Based Testing?
- [ ] Tester les propriétés CSS
- [ ] Tester les variables de classe
- [x] Tester des propriétés générales plutôt que des cas spécifiques
- [ ] Tester les droits de propriété intellectuelle

---

# Dans quelle phase du Processus Unifié l'implémentation est-elle maximale?
- [ ] Création
- [ ] Élaboration
- [x] Construction
- [ ] Transition

---

# Qu'est-ce qu'un critère de succès d'une itération?
- [ ] Avoir écrit beaucoup de code
- [ ] Avoir fait beaucoup de réunions
- [x] Avoir atteint tous les objectifs de qualité prévus
- [ ] Avoir travaillé beaucoup d'heures

---

# Quel est le rôle de l'intégrateur dans la discipline d'implémentation?
- [ ] Écrire tout le code
- [ ] Tester manuellement le système
- [x] Planifier et réaliser l'intégration des composants
- [ ] Gérer le budget du projet

---

# Qu'est-ce qu'un facteur de risque?
- [ ] Un risque très important
- [x] L'origine d'un risque ou ensemble de risques
- [ ] Un risque qui s'est réalisé
- [ ] Un risque accepté

---

# Quelles sont les trois catégories de risques?
- [ ] Petit, Moyen, Grand
- [x] Projet, Technique, Affaire
- [ ] Court terme, Moyen terme, Long terme
- [ ] Évitable, Inévitable, Acceptable

---

# Que signifie "atténuer" un risque?
- [ ] L'ignorer complètement
- [ ] Le transférer à quelqu'un d'autre
- [x] Prendre des mesures proactives pour réduire sa probabilité ou son impact
- [ ] Attendre qu'il se produise

---

# Quel est un indicateur de risque technologique?
- [ ] Équipe joyeuse
- [ ] Budget respecté
- [x] Livraison tardive de matériel ou nombreux problèmes techniques
- [ ] Client satisfait

---

# Qu'est-ce qu'un Plan de développement logiciel (SDL)?
- [ ] Un document de 2 pages
- [ ] Le code source commenté
- [x] L'ensemble complet d'artefacts pour gérer le projet
- [ ] Le manuel utilisateur

---

# Que contient un plan d'itération?
- [ ] La vision globale du projet sur 12 mois
- [x] La séquence détaillée des tâches sur 2-4 semaines
- [ ] Le budget total du projet
- [ ] La liste de tous les risques

---

# Quel est un bénéfice du déploiement continu?
- [ ] Moins de tests nécessaires
- [ ] Plus de documentation
- [x] Réduction du stress grâce aux déploiements fréquents
- [ ] Élimination de tous les bugs

---

# Que doit-on automatiser en déploiement continu?
- [ ] Seulement les tests
- [ ] Seulement le build
- [x] Tout le processus de déploiement
- [ ] Rien, tout doit être manuel

---

# Explanations

# Question 1
Un processus logiciel est essentiel pour gérer la complexité des projets de développement. Il fournit une structure et des pratiques qui aident l'équipe à coordonner son travail, à maintenir la qualité et à s'adapter aux changements. Sans processus, les projets risquent de devenir chaotiques, surtout à mesure qu'ils grandissent en taille et en complexité.

# Question 2
Les étapes de construction d'une équipe suivent le modèle de Tuckman : Formation (l'équipe se forme), Turbulence (les conflits émergent), Normalisation (les règles s'établissent), Performance (l'équipe est productive), et Dissolution (le projet se termine). Ces étapes sont naturelles et importantes pour qu'une équipe devienne performante.

# Question 3
Une équipe maillée est une équipe auto-organisée où le leadership n'est pas centralisé mais distribué. Les membres de l'équipe prennent des initiatives et des responsabilités. Les ingrédients clés incluent la confiance mutuelle, la communication ouverte, et l'engagement partagé vers les objectifs communs.

# Question 4
L'extrant d'un projet logiciel (le code, la documentation) est moins tangible qu'un produit physique comme un pont ou une voiture. On ne peut pas le "toucher" ou facilement évaluer son avancement juste en le regardant, ce qui rend la gestion plus complexe et nécessite des métriques et des pratiques spécifiques.

# Question 5
Un cycle de vie de développement logiciel définit l'ensemble des phases par lesquelles passe un projet, de la conception initiale jusqu'à la livraison et la maintenance. Il structure le travail et aide à planifier les différentes activités du projet.

# Question 6
Dans le cycle en cascade, chaque phase doit être complétée avant de passer à la suivante. Une fois qu'on a avancé, il est très difficile et coûteux de revenir en arrière pour faire des changements. Cela rend ce cycle rigide et peu adapté aux projets où les exigences peuvent évoluer.

# Question 7
Le Processus Unifié comprend quatre phases dans cet ordre : Création (établir la vision et la faisabilité), Élaboration (définir l'architecture), Construction (développer le système), et Transition (déployer le système). Chaque phase a des objectifs spécifiques et se termine par un jalon.

# Question 8
Le jalon LCO (Lifecycle Objectives) marque la fin de la phase de Création. À ce moment, on a établi la vision du projet, identifié les cas d'utilisation principaux, et démontré la faisabilité technique et commerciale du projet.

# Question 9
Une itération est un mini-projet de durée fixe (généralement 2-4 semaines) qui produit un incrément fonctionnel du système. Chaque itération inclut planification, analyse, conception, implémentation, test et intégration, résultant en un produit potentiellement livrable.

# Question 10
Les processus agiles valorisent l'adaptation au changement plutôt que de suivre rigidement un plan initial. Ils reconnaissent que les besoins évoluent et que l'équipe doit pouvoir ajuster sa direction en fonction des apprentissages et du feedback.

# Question 11
La Gestion de Configuration et Changements vise à contrôler l'évolution des artefacts du projet de manière systématique. Elle permet de savoir qui a modifié quoi, quand et pourquoi, et de gérer les différentes versions du système tout au long de son développement.

# Question 12
Un élément de configuration est un artefact ou un ensemble d'artefacts (comme un fichier de code, un document, ou un module complet) qui est traité comme une entité unique dans le système de gestion de configuration. Il peut être versionné et tracé individuellement.

# Question 13
Dans un système distribué comme Git, chaque développeur possède une copie complète de l'historique du projet sur sa machine locale. Cela permet de travailler hors ligne, de faire des commits locaux, et offre une meilleure résilience (si le serveur central tombe, chaque développeur a une copie complète).

# Question 14
Une base de référence (baseline) est un ensemble d'éléments de configuration qui ont été formellement revus et approuvés à un moment donné. Elle représente une configuration stable du projet à laquelle on peut se référer ou revenir si nécessaire.

# Question 15
Un besoin exprime un problème ou une opportunité du point de vue de l'utilisateur ou du client (QUOI). Une exigence est une solution spécifique ou une capacité que le système doit avoir pour répondre à ce besoin (COMMENT). Un besoin peut se traduire en plusieurs exigences.

# Question 16
Les trois types sont : Fonctionnelles (ce que le système doit faire : calculs, traitements, fonctionnalités), Non-fonctionnelles (comment le système doit être : performance, sécurité, utilisabilité), et Contraintes (limitations imposées : budget, technologie, règlements).

# Question 17
Une partie prenante est toute personne ou organisation qui est affectée par le système ou qui peut l'influencer. Cela inclut les utilisateurs finaux, les clients, les développeurs, les gestionnaires, les régulateurs, etc. Identifier toutes les parties prenantes est crucial pour bien comprendre les besoins.

# Question 18
La traçabilité entre exigences et tests garantit que chaque exigence est effectivement testée et validée. Cela permet de s'assurer qu'on n'a rien oublié et que le système répond bien à tous les besoins identifiés. C'est aussi utile pour évaluer l'impact des changements d'exigences.

# Question 19
L'analyse se concentre sur la compréhension du problème (QUOI faire, quels sont les besoins) tandis que la conception se concentre sur la solution (COMMENT le faire, quelle architecture, quelles technologies). L'analyse est orientée problème, la conception est orientée solution.

# Question 20
L'architecture logicielle définit l'organisation fondamentale d'un système : ses composants principaux, leurs relations, et les principes qui guident leur évolution. Elle établit les décisions structurelles majeures qui seront difficiles à changer plus tard.

# Question 21
Une bonne architecture facilite la maintenance (plus facile de comprendre et modifier), l'évolution (plus facile d'ajouter des fonctionnalités), la réutilisation (composants réutilisables), et la gestion de la complexité (système organisé et compréhensible).

# Question 22
Les modèles (diagrammes UML, maquettes, prototypes) permettent de visualiser, comprendre et communiquer sur le système avant de le construire. Ils aident à identifier les problèmes tôt, à valider les idées avec les parties prenantes, et à guider l'implémentation.

# Question 23
Les quatre compétences distinctes sont : Programmer (traduire la conception en code), Déboguer (enlever les fautes de programmation comme les erreurs de syntaxe), Tester unitairement (enlever les fautes de traduction/logique), et Intégrer (assembler les composants et identifier les fautes de système).

# Question 24
Les tests unitaires permettent d'enlever les fautes de traduction, c'est-à-dire les erreurs dans l'implémentation de la logique métier. Par exemple, une mauvaise gestion d'une division par zéro ou une condition incorrecte sont des fautes de traduction détectées par les tests unitaires.

# Question 25
Un test unitaire est un code automatisé qui teste une unité (classe, méthode, fonction) en isolation. Il utilise des mocks pour simuler les dépendances et vérifie que le comportement logique de l'unité est celui attendu. Il doit être rapide, indépendant et répétable.

# Question 26
F.I.R.S.T. signifie : Fast (rapide à exécuter), Independent (indépendant des autres tests), Repeatable (donne toujours le même résultat), Self-validating (passe ou échoue automatiquement), Timely (écrit au bon moment, idéalement avant le code de production en TDD).

# Question 27
En intégration continue, chaque membre de l'équipe devrait intégrer son code au moins une fois par jour, menant idéalement à plusieurs intégrations quotidiennes. Plus les intégrations sont fréquentes, plus les conflits sont petits et faciles à résoudre.

# Question 28
En intégration continue, TOUS les tests doivent passer, soit 100%. Pas 90%, pas 95%, mais 100%. Un seul test qui échoue signifie que le build est cassé et doit être réparé immédiatement avant toute autre chose.

# Question 29
Si le build d'intégration continue échoue, le développeur responsable du commit qui a causé l'échec doit réparer le code sans délai. C'est une priorité absolue car un build cassé bloque tout le monde. Les autres développeurs peuvent aider à résoudre le problème.

# Question 30
Le test unitaire utilise des mocks pour isoler complètement l'unité testée de ses dépendances. Le test d'intégration n'utilise PAS de mocks mais teste la collaboration réelle entre plusieurs composants avec leurs vraies implémentations.

# Question 31
Non, les tests unitaires font partie de la discipline d'implémentation car ils sont écrits par les développeurs en même temps que le code, testent la traduction de la conception en code, et font partie du processus de développement quotidien. Ils sont exécutés avant l'intégration.

# Question 32
Un test de système (end-to-end) teste le système complet dans son ensemble, de l'interface utilisateur jusqu'à la base de données. Il teste aussi la configuration du système et son déploiement. C'est le niveau de test le plus haut et le plus lent.

# Question 33
Les tests d'acceptation avec Cucumber utilisent le format Given-When-Then avec le langage Gherkin. Given décrit les préconditions, When décrit l'action effectuée, et Then décrit le résultat attendu. Ce format est compréhensible par les non-techniques.

# Question 34
La pyramide des tests recommande : beaucoup de tests unitaires à la base (rapides, nombreux, couvrent tous les cas), quelques tests d'intégration au milieu (testent les interactions), et peu de tests de système au sommet (lents, fragiles, testent la configuration).

# Question 35
Mathématiquement, si on a 3 fonctions avec 5, 7 et 3 cas chacune, les tester par intégration nécessite 5×7×3=105 tests, mais les tester unitairement ne nécessite que 5+7+3=15 tests. Les tests unitaires sont plus efficaces pour couvrir tous les cas.

# Question 36
Non, les tests ne créent pas la qualité, ils la confirment ou la révèlent. Certains facteurs de qualité comme la performance doivent être construits dès le départ avec une approche préventive. Les tests sont une approche corrective, pas préventive.

# Question 37
Un processus décrit les quatre éléments : QUI (le rôle qui effectue le travail), QUOI (l'artefact produit ou utilisé), COMMENT (l'activité effectuée), et QUAND (l'enchaînement temporel des activités).

# Question 38
Les trois dimensions interdépendantes d'un projet sont : la Qualité (technique - nombre de bugs, performance), le Temps (durée de réalisation), et le Coût (effort nécessaire, budget). C'est le triangle de fer : modifier l'une impacte nécessairement les autres.

# Question 39
Dans les projets logiciels, la principale ressource est le travail intellectuel des spécialistes. Ce type de travail est difficile à mesurer et à gérer. On ne peut pas facilement évaluer la progression d'un développeur qui réfléchit à une architecture complexe, contrairement à un projet physique où on voit l'avancement.

# Question 40
La planification à deux niveaux comprend : le Plan du projet (niveau grossier, inter-itération) qui donne une vision globale sur 6-12 mois définissant les phases et itérations, et le Plan d'itération (niveau détaillé, intra-itération) qui décrit précisément les tâches sur 2-4 semaines.

# Question 41
Un risque est une variable dont la valeur peut mettre en danger ou réduire le succès d'un projet. C'est la probabilité qu'un événement indésirable ait lieu. Un risque n'est pas encore un problème, c'est quelque chose qui pourrait devenir un problème.

# Question 42
Le risque se calcule par : RISQUE = INCERTITUDE × PERTE. L'incertitude représente la probabilité que l'événement se produise, et la perte représente l'impact négatif si l'événement se produit. Plus l'un ou l'autre est élevé, plus le risque est grand.

# Question 43
Les quatre étapes sont : 1) Identifier les risques (trouver les causes potentielles et risques critiques), 2) Analyser les risques (évaluer les conséquences), 3) Se préparer aux risques (trouver des solutions pour les réduire), 4) Surveiller (piloter la mise en œuvre des solutions).

# Question 44
Les cinq stratégies sont : Éviter (réorganiser pour que le risque ne puisse pas affecter), Transférer (faire supporter le risque par quelqu'un d'autre comme un sous-traitant), Accepter (vivre avec le risque), Atténuer (mesures proactives pour réduire probabilité/impact), Plan B (plan d'action si le risque se réalise).

# Question 45
Les risques de processus concernent les problèmes potentiels liés aux pratiques du génie logiciel utilisées par l'équipe : mauvaise compréhension des requis, mauvais choix architecturaux, mauvaises planifications, implémentation inefficace, tests déficients, dégradation du produit. On adopte un processus pour réduire ces risques.

# Question 46
Le déploiement continu est une approche dans laquelle les fonctionnalités logicielles sont livrées fréquemment par le biais de déploiements automatisés. Au lieu de déployer une fois en fin de projet, on déploie régulièrement tout au long du développement.

# Question 47
Les trois environnements sont : Développement (où on développe le code, travail collaboratif quotidien), Staging (simulé aussi similaire que possible à production pour les tests finaux), et Production (système live avec utilisateurs réels, génération de revenus).

# Question 48
Le Staging est un environnement qui simule l'environnement de production aussi fidèlement que possible. Il permet de tester le déploiement et les fonctionnalités dans des conditions quasi-réelles avant de déployer en production, réduisant ainsi les risques.

# Question 49
Les trois objectifs sont : 1) Visibilité totale (toutes les étapes visibles pour favoriser collaboration), 2) Rétroaction rapide (identifier et résoudre les problèmes le plus tôt possible - fail fast, fail cheap), 3) Capacité de déploiement à volonté (déployer n'importe quelle version automatiquement).

# Question 50
"Done means released" signifie que terminé veut dire déployé en production, pas juste que le code est écrit ou que les tests passent. Le travail n'est vraiment terminé que quand il est accessible aux utilisateurs et génère de la valeur.

# Question 51
Un anti-pattern du déploiement continu est de déployer manuellement avec une documentation importante décrivant les étapes. Cela prend beaucoup de temps, est sujet aux erreurs humaines, et rend les déploiements stressants. Les déploiements doivent être automatisés.

# Question 52
Le principe "si ça fait mal, faites-le plus souvent et plus tôt" signifie que plus on pratique quelque chose, plus ça devient facile et naturel. En déployant fréquemment, le processus devient routinier, moins stressant, et les problèmes sont détectés plus tôt quand ils sont plus faciles à corriger.

# Question 53
Le cycle en cascade est adapté aux projets où les exigences sont très bien définies dès le départ, stables (ne changeront pas), et où le domaine est bien connu. Par exemple, un projet de remplacement d'un système existant avec des exigences claires et fixes.

# Question 54
Dans un cycle incrémental, à chaque incrément on livre une partie fonctionnelle du système qui peut être testée et éventuellement utilisée. Le système grandit progressivement, ajoutant des fonctionnalités à chaque incrément jusqu'à obtenir le système complet.

# Question 55
Un processus cérémonieux a beaucoup de formalisme et de documentation (comme RUP complet avec tous ses artefacts), tandis qu'un processus opportuniste a peu de formalisme et privilégie la flexibilité et l'adaptation (comme les méthodes agiles). Le choix dépend du contexte du projet.

# Question 56
Les trois dimensions de la GCC sont : 1) Gestion des versions (tracking des changements au code), 2) Gestion des changements (processus pour demander, évaluer et approuver les modifications), et 3) Gestion des builds (compilation et assemblage automatiques du système).

# Question 57
Les bases de référence marquent des configurations stables et testées du système à des moments clés du projet. Elles permettent de revenir à un état connu et fonctionnel si nécessaire, et servent de points de repère pour mesurer l'avancement.

# Question 58
Une exigence fonctionnelle décrit ce que le système doit faire, les fonctionnalités et comportements attendus. Par exemple : "Le système doit permettre à l'utilisateur de se connecter avec un nom d'utilisateur et un mot de passe" ou "Le système doit calculer la taxe sur une vente".

# Question 59
Une exigence non-fonctionnelle décrit comment le système doit être ou performer, plutôt que ce qu'il fait. Elle concerne la qualité du service : performance (temps de réponse), sécurité, fiabilité, utilisabilité, maintenabilité, etc. Par exemple : "Le système doit répondre en moins de 2 secondes".

# Question 60
Un processus itératif permet d'obtenir du feedback à chaque itération et d'adapter les exigences en conséquence. On peut prioriser les exigences les plus importantes, les raffiner progressivement, et ajuster selon ce qu'on apprend. C'est plus flexible qu'un processus en cascade où tout doit être défini au départ.

# Question 61
Le Design by Contract est une approche où on définit explicitement les préconditions (ce qui doit être vrai avant l'exécution d'une méthode), les postconditions (ce qui doit être vrai après), et les invariants (ce qui doit toujours être vrai pour une classe). Cela clarifie les responsabilités et facilite les tests.

# Question 62
Le diagramme de classes UML modélise la structure statique du système : les classes, leurs attributs, leurs méthodes, et les relations entre elles (héritage, association, composition, etc.). Il est utilisé pour visualiser et concevoir l'architecture orientée objet.

# Question 63
Les tests unitaires selon Design by Contract vérifient que les préconditions (les paramètres sont valides), les postconditions (le résultat est correct) et les invariants de classe (l'état de l'objet reste cohérent) sont respectés. Cela garantit que le contrat de chaque méthode est bien implémenté.

# Question 64
La structure 3A (Arrange-Act-Assert) organise les tests unitaires en trois parties claires : Arrange (préparer les données de test et l'environnement), Act (appeler la méthode sous test), Assert (vérifier que le résultat est celui attendu). Cette structure rend les tests plus lisibles et maintenables.

# Question 65
Les Mocks sont des objets simulés qui remplacent les dépendances réelles d'une unité de code. Ils permettent d'isoler complètement l'unité testée en contrôlant le comportement de ses dépendances. On peut ainsi tester l'unité sans être affecté par des problèmes dans ses dépendances.

# Question 66
La règle d'or du refactoring est de toujours refactorer avec des tests qui passent. On ne doit jamais refactorer du code cassé ou sans couverture de tests. Les tests garantissent qu'on n'a pas changé le comportement externe du code pendant le refactoring.

# Question 67
KISS signifie "Keep It Simple, Stupid!" C'est un principe qui encourage à garder la conception et l'implémentation simples. On ne doit pas sur-concevoir ou ajouter de la complexité inutile. Il faut implémenter ce qui est nécessaire maintenant, pas ce qui pourrait être nécessaire dans le futur.

# Question 68
En intégration continue, il faut faire des commits fréquents (au moins quotidiennement), ne jamais commiter du code qui ne compile pas ou dont les tests échouent, et réparer immédiatement tout build cassé. Ces pratiques maintiennent la base de code toujours en état fonctionnel.

# Question 69
Le TDD (Test-Driven Development) consiste à écrire d'abord un test qui échoue (parce que la fonctionnalité n'existe pas encore), puis écrire le code minimum pour faire passer ce test, puis refactorer le code. Ce cycle (Red-Green-Refactor) garantit que tout le code est testé.

# Question 70
Évaluer les tests permet de garantir que les tests eux-mêmes sont de qualité et qu'ils couvrent bien les aspects cruciaux du système. Sans évaluation, on ne peut pas savoir si les tests sont efficaces, complets, ou s'ils testent vraiment ce qui est important.

# Question 71
Le Property-Based Testing teste des propriétés générales que le code doit toujours respecter, plutôt que des cas spécifiques. Par exemple, "pour tout nombre x, Math.abs(x) >= 0". La bibliothèque génère automatiquement des cas de test pour tenter de violer la propriété.

# Question 72
L'implémentation est présente dans toutes les phases mais est maximale pendant la phase de Construction. C'est dans cette phase qu'on développe la majorité des fonctionnalités du système. Dans Création et Élaboration, il y a peu d'implémentation (surtout des prototypes), et dans Transition, il n'y a que des corrections.

# Question 73
Une itération est considérée réussie quand : 1) Tous les risques identifiés ont été minimisés selon le plan, 2) Toutes les fonctionnalités prévues ont été réalisées et testées, et 3) Tous les objectifs de qualité ont été atteints. Tous ces critères doivent être satisfaits.

# Question 74
L'intégrateur est responsable de planifier l'intégration des différents composants développés par les implémenteurs, de réaliser cette intégration, de gérer les dépendances entre modules, et de coordonner le travail. Il s'assure que les composants fonctionnent bien ensemble.

# Question 75
Un facteur de risque est l'origine ou la cause d'un risque. C'est l'élément déclencheur qui peut mener à un ou plusieurs risques. Par exemple, "nouvelle technologie" est un facteur de risque qui peut causer plusieurs risques : difficulté d'apprentissage, bugs imprévus, problèmes de performance, etc.

# Question 76
Les trois catégories de risques sont : Risques de projet (concernent le déroulement : perte d'employé, retard de matériel), Risques techniques (concernent la qualité du produit : problèmes de performance, outils défectueux), et Risques d'affaire (affectent l'organisation : concurrence, changements de marché).

# Question 77
Atténuer un risque signifie prendre des mesures proactives pour réduire soit sa probabilité d'occurrence, soit son impact s'il se produit. Par exemple, former l'équipe à une nouvelle technologie réduit le risque lié au manque de compétences.

# Question 78
Les indicateurs de risques technologiques incluent : livraison tardive de matériel ou logiciel, nombreux problèmes techniques rapportés, plaintes sur les outils, difficultés d'intégration, etc. Ces signes suggèrent que les risques technologiques se matérialisent.

# Question 79
Le Plan de développement logiciel (SDL) est l'ensemble complet d'artefacts contenant toute l'information nécessaire pour gérer le projet. Il inclut le plan de mesure, le plan d'itération, la liste des risques, et d'autres documents de planification et de suivi.

# Question 80
Un plan d'itération contient la séquence temporelle détaillée des tâches pour les 2-4 prochaines semaines, l'assignation précise des ressources (qui fait quoi), les dépendances entre tâches, et l'identification des principales composantes à développer dans cette itération.

# Question 81
Le déploiement continu réduit le stress car les déploiements deviennent routiniers et fréquents plutôt que de grands événements rares et stressants. Plus on déploie souvent, plus le processus devient naturel et maîtrisé. C'est le principe "practice makes perfect".

# Question 82
En déploiement continu, tout le processus doit être automatisé (ou presque) : le build, les tests, le déploiement en staging, les tests en staging, et le déploiement en production. L'automatisation réduit les erreurs humaines, accélère le processus, et le rend répétable.